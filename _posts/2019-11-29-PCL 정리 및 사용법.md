#PCL cheat sheet

## pcl type 선언

pcl type 종류 참고:</br> 

http://www.pointclouds.org/documentation/tutorials/adding_custom_ptype.php#adding-custom-ptype
```cpp
pcl::PointCloud<pcl::PointXYZ> cloud;
pcl::PointCloud<pcl::PointXYZI> cloud;
pcl::PointCloud<pcl::PointNormal> cloud;
```
## Functions

```cpp
pcl::PointCloud<pcl::PointXYZ> cloud;
cloud.size();
cloud.resize(2);
```

>>>2

## pcl type 선언

```cpp
pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>());
pcl::PointCloud<pcl::PointXYZI>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZI>());
pcl::PointCloud<pcl::PointNormal>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZNormal>());
```


**input: foo**</br>
**output: var**
```cpp
var foo = function(x) {
  return(x + 5);
}
foo(3)
```
## pcl::PointXYZ ptr 선언

## sensor_msgs::Pointcloud2 in ROS to pcl::PointCloud

## pcl::PointCloud to sensor_msgs::Pointcloud2 in ROS 

## pcl
```cpp
pcl::PointCloud<pcl::PointXYZ> output;
   pcl::PointCloud<pcl::PointXYZ>::Ptr filtered(new pcl::PointCloud<pcl::PointXYZ>);
   pcl::fromROSMsg(msg->velodyne, output);
   // For debugging


   pcl::PassThrough<pcl::PointXYZ> filter;
   Eigen::Matrix4f trans;
   trans<< 0.0174524,  -0.9998477,  0, -0.001,
                   0,           0, -1, -0.095,
           0.9998477,   0.0174524,  0, -0.064,
                   0,           0,  0,     1;
//   trans<< 0,  -1,  0, 0.000,
//           0,   0, -1, -0.10,
//           1,   0,  0, -0.07,
//           0,   0,  0,     1;
   pcl::transformPointCloud(output,*filtered,trans);
   filter.setInputCloud(filtered);
   filter.setFilterFieldName("z");
   filter.setFilterLimits(0, m_max_range);
   filter.filter(*filtered);
```

## Test
```cpp
pcl::fromROSMsg(pose_vec.back().pc2, cloud_t);
  pcl::PointCloud<pcl::PointXYZ> cloud_t_cut_by_dist = cvt::cloud2cloudcut(cloud_t,pcl::PointXYZ(0,0,0),0.5,20);
  Eigen::Matrix4f tf_velodyne2base = cvt::geoPose2eigen(pose_vec.back().T_laser2rt);
  Eigen::Matrix4f tf_base2origin = cvt::geoPose2eigen(pose_vec.back().T_laser2rt);
  pcl::transformPointCloud(cloud_t_cut_by_dist, cloud_t, tf_base2origin * tf_velodyne2base);
```

##

Eigen::Matrix4f transform_base = Eigen::Matrix4f::Identity(4,4);
  /*Convert Pontcloud msgs to pcl::pointcloud*/
  pcl::PCLPointCloud2 pcl_pc2;
  pcl_conversions::toPCL(msg.query_pts,pcl_pc2);
  pcl::fromPCLPointCloud2(pcl_pc2,*pointcloud_query);
  pcl_conversions::toPCL(msg.train_pts,pcl_pc2);
  pcl::fromPCLPointCloud2(pcl_pc2,*pointcloud_train);
  /*Voxelize each query and train pointcloud into specific point size*/
  pcl::VoxelGrid<pcl::PointXYZ> voxelfilt;
  voxelfilt.setInputCloud(pointcloud_query);
  voxelfilt.setLeafSize(m_var_voxelsize,m_var_voxelsize,m_var_voxelsize);
  voxelfilt.filter(*pointcloud_query_voxel);
  voxelfilt.setInputCloud(pointcloud_train);
  voxelfilt.setLeafSize(m_var_voxelsize,m_var_voxelsize,m_var_voxelsize);
  voxelfilt.filter(*pointcloud_train_voxel);

## Hey

   std::cout<<"Receiving " <<msg->idx<<"th synced data!"<<std::endl;
////For scan0 data
   pcl::PointCloud<pcl::PointXYZ> scan0_pc;
   pcl::fromROSMsg(msg->scan0, scan0_pc);
   std::cout<<"[MERGER]: scan0 - "<<scan0_pc.points.size()<<std::endl;
////For scan1 data
   pcl::PointCloud<pcl::PointXYZ> scan1_pc;
   pcl::PointCloud<pcl::PointXYZ>::Ptr filtered(new pcl::PointCloud<pcl::PointXYZ>);
   pcl::fromROSMsg(msg->scan1, scan1_pc);

   Eigen::Matrix4f trans;
   //// Case 1 trasformation
//   trans<<      1,        0,  0,   -0.1,
//                0,        1,  0,   1.76,
//                0,        0,  1,      0,
//                0,        0,  0,      1;

   //// Case 2 trasformation - In CARPE
   trans<<      0,        1,  0,   1.54,
               -1,        0,  0,   1.54,
                0,        0,  1,      0,
                0,        0,  0,      1;

   //// Case 3 trasformation - In Lab
//   trans<<     -1,        0,  0,   3.08,
//                0,       -1,  0,      0,
//                0,        0,  1,      0,
//                0,        0,  0,      1;

```cpp
   pcl::transformPointCloud(scan1_pc,*filtered,trans);
   // For debugging
   std::cout<<"[MERGER]: scan1 - "<<filtered->points.size()<<std::endl;
   pcl::PointCloud<pcl::PointXYZ> merged_pc;
   merged_pc = scan0_pc;
   merged_pc += *filtered;

   m_pub_bf_filtered_debug.publish(cvt::cloud2msg(merged_pc));

   //// Filtering using statistical outlier removal
   pcl::PointCloud<pcl::PointXYZ>::Ptr sor_filtered(new pcl::PointCloud<pcl::PointXYZ>);
   *sor_filtered = merged_pc;

   //// Filter wall pts
   pcl::PassThrough<pcl::PointXYZ> filter;
   filter.setInputCloud(sor_filtered);
   filter.setFilterFieldName("x");
   filter.setFilterLimits(-2.0, 3.3);
   filter.filter(*sor_filtered);

   filter.setInputCloud(sor_filtered);
   filter.setFilterFieldName("y");
   filter.setFilterLimits(-3, 100);
   filter.filter(*sor_filtered);


   pcl::StatisticalOutlierRemoval<pcl::PointXYZ> sor;
   sor.setInputCloud (sor_filtered);
   // Set neighbors to analyze for each point
   sor.setMeanK (10);
   sor.setStddevMulThresh (1.0);
   sor.filter(*sor_filtered);

   m_pub_after_filtered_debug.publish(cvt::cloud2msg(*sor_filtered));

   //// Segment points
   pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_f(new pcl::PointCloud<pcl::PointXYZ>);
   pcl::SACSegmentation<pcl::PointXYZ> seg;
   pcl::PointIndices::Ptr inliers (new pcl::PointIndices);
   pcl::ModelCoefficients::Ptr coefficients (new pcl::ModelCoefficients);
   pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_plane (new pcl::PointCloud<pcl::PointXYZ> ());
   seg.setOptimizeCoefficients (true);
   seg.setModelType (pcl::SACMODEL_PLANE);
   seg.setMethodType (pcl::SAC_RANSAC);
   seg.setMaxIterations (100);
   seg.setDistanceThreshold (0.02);

   // Creating the KdTree object for the search method of the extraction
   pcl::search::KdTree<pcl::PointXYZ>::Ptr tree (new pcl::search::KdTree<pcl::PointXYZ>);
   tree->setInputCloud (sor_filtered);

   std::vector<pcl::PointIndices> cluster_indices;
   pcl::EuclideanClusterExtraction<pcl::PointXYZ> ec;

   //  If too small, it can happen that an actual object can be seen as multiple clusters
   //  multiple objects are seen as one cluster.
   ec.setClusterTolerance (0.28); // 2cm
   ec.setMinClusterSize (5);
   ec.setMaxClusterSize (100);
   ec.setSearchMethod (tree);
   ec.setInputCloud (sor_filtered);

   ec.extract (cluster_indices);
```
