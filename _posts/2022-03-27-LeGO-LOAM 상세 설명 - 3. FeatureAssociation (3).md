---
layout: post
title: LeGO-LOAM 상세 설명 - 3. FeatureAssociation (3)
subtitle: Edge and Planar Feature Extraction
tags: [SLAM, LiDAR, Pointcloud, ROS, PCL, LeGO-LOAM]
comments: true
---

# FeatureAssociation in LeGO-LOAM (3) Transformation

최종적으로 t-1과 t의 feature를 구했으면, 주어진 feature들을 바탕으로 relative pose를 구한다. 흔히 알고 있듯이 planar feature를 통해 z, roll, pitch가 optimize하고 edge feature를 통해 x, y, yaw가 optimize하는, two-stage optimization 방식을 따른다.

![](/img/lego_loam_two_stage_optimization.PNG)


다른 section과 다르게 이 부분에서는 L-M optimization을 하는 부분의 설명이 필요하다보니 좀더 수학수학해졌다 :(. 아래의 링크들이 도움이 되리라 생각된다.
* [Least square, Iterative method, L-M optimization](https://www.slideshare.net/phani279/lecture-5-15476418)
* [Cross product](https://en.wikipedia.org/wiki/Cross_product)
* [Partial derivative](https://www.khanacademy.org/math/multivariable-calculus/multivariable-derivatives/partial-derivative-and-gradient-articles/a/introduction-to-partial-derivatives)


### updateTransformation()

Pose estimation하는 부분은 자명하다. 크게 **a) Correspondence 찾기**와 **b) non-linear optmizaton을 통한 parameter update하기**로 나눠지고, 이는 각각 planar feature과 edge feature에 대해 행해진다.

```cpp
void updateTransformation(){
    if (laserCloudCornerLastNum < 10 || laserCloudSurfLastNum < 100)
        return;

    for (int iterCount1 = 0; iterCount1 < 25; iterCount1++) {
        laserCloudOri->clear();
        coeffSel->clear();

        findCorrespondingSurfFeatures(iterCount1);

        if (laserCloudOri->points.size() < 10)
            continue;
        if (calculateTransformationSurf(iterCount1) == false)
            break;
    }

    for (int iterCount2 = 0; iterCount2 < 25; iterCount2++) {

        laserCloudOri->clear();
        coeffSel->clear();

        findCorrespondingCornerFeatures(iterCount2);

        if (laserCloudOri->points.size() < 10)
            continue;
        if (calculateTransformationCorner(iterCount2) == false)
            break;
    }
}
```

순서는 planar -> corner 순으로 optimization을 진행하지만, 둘의 구조와 알고리즘 상의 방법론이 동일하기 때문에, 수식이 좀 더 쉬운 corner feature에 대해 먼저 설명한다.

### findCorrespondingCornerFeatures(iterCount2)

```cpp
void findCorrespondingCornerFeatures(int iterCount){

    int cornerPointsSharpNum = cornerPointsSharp->points.size();

    for (int i = 0; i < cornerPointsSharpNum; i++) {

        TransformToStart(&cornerPointsSharp->points[i], &pointSel);

        if (iterCount % 5 == 0) {

            kdtreeCornerLast->nearestKSearch(pointSel, 1, pointSearchInd, pointSearchSqDis);
            int closestPointInd = -1, minPointInd2 = -1;

            if (pointSearchSqDis[0] < nearestFeatureSearchSqDist) {
                closestPointInd = pointSearchInd[0];
                int closestPointScan = int(laserCloudCornerLast->points[closestPointInd].intensity);

                float pointSqDis, minPointSqDis2 = nearestFeatureSearchSqDist;
                for (int j = closestPointInd + 1; j < cornerPointsSharpNum; j++) {
                    if (int(laserCloudCornerLast->points[j].intensity) > closestPointScan + 2.5) {
                        break;
                    }

                    pointSqDis = (laserCloudCornerLast->points[j].x - pointSel.x) * 
                                 (laserCloudCornerLast->points[j].x - pointSel.x) + 
                                 (laserCloudCornerLast->points[j].y - pointSel.y) * 
                                 (laserCloudCornerLast->points[j].y - pointSel.y) + 
                                 (laserCloudCornerLast->points[j].z - pointSel.z) * 
                                 (laserCloudCornerLast->points[j].z - pointSel.z);

                    if (int(laserCloudCornerLast->points[j].intensity) > closestPointScan) {
                        if (pointSqDis < minPointSqDis2) {
                            minPointSqDis2 = pointSqDis;
                            minPointInd2 = j;
                        }
                    }
                }
                for (int j = closestPointInd - 1; j >= 0; j--) {
                    if (int(laserCloudCornerLast->points[j].intensity) < closestPointScan - 2.5) {
                        break;
                    }

                    pointSqDis = (laserCloudCornerLast->points[j].x - pointSel.x) * 
                                 (laserCloudCornerLast->points[j].x - pointSel.x) + 
                                 (laserCloudCornerLast->points[j].y - pointSel.y) * 
                                 (laserCloudCornerLast->points[j].y - pointSel.y) + 
                                 (laserCloudCornerLast->points[j].z - pointSel.z) * 
                                 (laserCloudCornerLast->points[j].z - pointSel.z);

                    if (int(laserCloudCornerLast->points[j].intensity) < closestPointScan) {
                        if (pointSqDis < minPointSqDis2) {
                            minPointSqDis2 = pointSqDis;
                            minPointInd2 = j;
                        }
                    }
                }
            }

            pointSearchCornerInd1[i] = closestPointInd;
            pointSearchCornerInd2[i] = minPointInd2;
        }

        if (pointSearchCornerInd2[i] >= 0) {

            tripod1 = laserCloudCornerLast->points[pointSearchCornerInd1[i]];
            tripod2 = laserCloudCornerLast->points[pointSearchCornerInd2[i]];

            float x0 = pointSel.x;
            float y0 = pointSel.y;
            float z0 = pointSel.z;
            float x1 = tripod1.x;
            float y1 = tripod1.y;
            float z1 = tripod1.z;
            float x2 = tripod2.x;
            float y2 = tripod2.y;
            float z2 = tripod2.z;

            float m11 = ((x0 - x1)*(y0 - y2) - (x0 - x2)*(y0 - y1));
            float m22 = ((x0 - x1)*(z0 - z2) - (x0 - x2)*(z0 - z1));
            float m33 = ((y0 - y1)*(z0 - z2) - (y0 - y2)*(z0 - z1));

            float a012 = sqrt(m11 * m11  + m22 * m22 + m33 * m33);

            float l12 = sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2) + (z1 - z2)*(z1 - z2));

            float la =  ((y1 - y2)*m11 + (z1 - z2)*m22) / a012 / l12;

            float lb = -((x1 - x2)*m11 - (z1 - z2)*m33) / a012 / l12;

            float lc = -((x1 - x2)*m22 + (y1 - y2)*m33) / a012 / l12;

            float ld2 = a012 / l12;

            float s = 1;
            if (iterCount >= 5) {
                s = 1 - 1.8 * fabs(ld2);
            }

            if (s > 0.1 && ld2 != 0) {
                coeff.x = s * la; 
                coeff.y = s * lb;
                coeff.z = s * lc;
                coeff.intensity = s * ld2;

                laserCloudOri->push_back(cornerPointsSharp->points[i]);
                coeffSel->push_back(coeff);
            }
        }
    }
}
```

위 함수는 다시 크게 두 파트로 나뉘어진다.

**i) Correspondence 찾기**: 가장 먼저, time t 상의 sharp한 corner feature와 가장 거리가 가까운 t-1 두 corner feature를 찾는다. 여기서 `kdtreeCornerLast`의 입력 point cloud는 t-1의 `cornerPointsLessSharp`이다. t-1에서 가장 가까운 점 1개를 찾은 후, 그 점을 기점으로 +-2.5ms (확인 요망) 근처에 있는 점을 l점으로 취급한다. 근데 코드 상에서 보면 +- check를 위->아래 순으로 체크하는 것 같다. 

최종적으로는 가장 가까운 점과 그 다음 가까운 점이 아래와 같이 할당된다. 만약 두 점의 거리의 제곱이 주어진 파라미터 `nearestFeatureSearchSqDist`보다 크면 잘못된 pair라고 상정한다. 기본적으로 `nearestFeatureSearchSqDist`는 25m^2으로 설정되어 있다. 가장 가까운 포인트와 그 다음 가까운 포인트는 아래와 같이 index가 저장된다.

```cpp
pointSearchCornerInd1[i] = closestPointInd;
pointSearchCornerInd2[i] = minPointInd2;
```

만약 할당이 제대로 되지 않았으면 -1이 세팅된다.

**ii) Optimization에 필요한 values 세팅**: 성공적으로 correspondence를 찾았으면 이제 향후 optimization에 필요한 값들을 세팅한다. 크게 아래의 세가지를 설정한다 (※수학주의).


1. Point-to-line distance

먼저 point-to-line distacne가 계산된다. 엄밀히 말하자면 외적(cross product)를 통해 두 line이 일치하는 정도를 측정한다. 외적을 하게 되면 크기x크기xsin(사잇각)이 되는데, 따라서 time t 상의 타겟 포인트와 t-1 상에서 타겟 포인트와 가장 가까운점과 그 다음 가까운 점을 각각 이은 두 선이 일치하는 쪽으로 향후에 optimize되는 것이다. 수식을 전개하기 위해 아래 그림으로 대체한다.

![](/img/lego_loam_fa_point_to_line.png)


2.Jacobian term

그 후, optimization에 필요한 jacobian term을 미리 구해둔다. 자료들을 찾아보면 저 `la`, `lb`, `lc`가 무엇인지 설명을 하지 않는데, 저 term은 향후에 non-linear optimization을 할 때 필요하다. Interative estimation method 기반으로 non-linear optimization을 하면 아래와 같이 표현할 수 있다.

![](/img/lego_loam_fa_solve.png)

Corner feature 같은 경우에는 아래와 같이 yaw, x, y (하지만 좌표축이 ZXY로 변했음을 기억하자. 따라서 r_y (yaw 회전), x_rel (왼쪽), z_rel (앞쪽)이 optimize된다)의 변화량이 풀어야할 파라미터가 된다. 하지만 jacobian matrix의 각 term을 구할 때 함수 (아래의 1, 2, 3)에 각 타겟 포인트에 대한 point-to-line distance의 derivate가 필요하다. 이 값은 r_y, x_rel, z_rel에 invariant하기 때문에 미리 계산해둔다. 수식 전개는 아래와 같다.


![](/img/lego_loam_fa_la_lb_lc.png)


3. Alternative weighting

또한 각 distance에 대한 weight가 아래와 같이 매겨진다.

```cpp
float s = 1;
if (iterCount >= 5) {
    s = 1 - 1.8 * fabs(ld2);
}

if (s > 0.1 && ld2 != 0) {
    coeff.x = s * la; 
    coeff.y = s * lb;
    coeff.z = s * lc;
    coeff.intensity = s * ld2;

    laserCloudOri->push_back(cornerPointsSharp->points[i]);
    coeffSel->push_back(coeff);
}
```

해석하자면,

* 초기 5번 iteration 동안은 모든 distance들에 대해 `s=1`로 세팅하여 모든 measurements의 중요한 정도 (weight)를 균등하게 둔다.
* 5번 이후에는 너무 `ld2`의 크기에 따라 weight를 달리하는데, 특히 0.1이하의 경우에는 향후 optimization에 사용하지 않는다. 즉, `s`에 0.1을 넣고 전개하면 `ld2`가 0.5m 이하인 점들만 유효한 measurements로 여긴다고 해석할 수 있다. 이는 아주 reasonable한데, 왜냐하면 주로 모바일 로봇들이 1~3m/s로 움직이기 때문이다. 따라서 적어도 point-to-line distance가 0.5m 이내의 점들이 유효한 pair이고 그 이외의 점들은 extreme outliers일 가능성이 크다.


### calculateTransformationCorner(iterCount2)

 
 
 ### findCorrespondingCornerFeatures(iterCount2)

```cpp
void findCorrespondingSurfFeatures(int iterCount){

    int surfPointsFlatNum = surfPointsFlat->points.size();

    for (int i = 0; i < surfPointsFlatNum; i++) {

        TransformToStart(&surfPointsFlat->points[i], &pointSel);

        if (iterCount % 5 == 0) {

            kdtreeSurfLast->nearestKSearch(pointSel, 1, pointSearchInd, pointSearchSqDis);
            int closestPointInd = -1, minPointInd2 = -1, minPointInd3 = -1;

            if (pointSearchSqDis[0] < nearestFeatureSearchSqDist) {
                closestPointInd = pointSearchInd[0];
                int closestPointScan = int(laserCloudSurfLast->points[closestPointInd].intensity);

                float pointSqDis, minPointSqDis2 = nearestFeatureSearchSqDist, minPointSqDis3 = nearestFeatureSearchSqDist;
                for (int j = closestPointInd + 1; j < surfPointsFlatNum; j++) {
                    if (int(laserCloudSurfLast->points[j].intensity) > closestPointScan + 2.5) {
                        break;
                    }

                    pointSqDis = (laserCloudSurfLast->points[j].x - pointSel.x) * 
                                 (laserCloudSurfLast->points[j].x - pointSel.x) + 
                                 (laserCloudSurfLast->points[j].y - pointSel.y) * 
                                 (laserCloudSurfLast->points[j].y - pointSel.y) + 
                                 (laserCloudSurfLast->points[j].z - pointSel.z) * 
                                 (laserCloudSurfLast->points[j].z - pointSel.z);

                    if (int(laserCloudSurfLast->points[j].intensity) <= closestPointScan) {
                        if (pointSqDis < minPointSqDis2) {
                          minPointSqDis2 = pointSqDis;
                          minPointInd2 = j;
                        }
                    } else {
                        if (pointSqDis < minPointSqDis3) {
                            minPointSqDis3 = pointSqDis;
                            minPointInd3 = j;
                        }
                    }
                }
                for (int j = closestPointInd - 1; j >= 0; j--) {
                    if (int(laserCloudSurfLast->points[j].intensity) < closestPointScan - 2.5) {
                        break;
                    }

                    pointSqDis = (laserCloudSurfLast->points[j].x - pointSel.x) * 
                                 (laserCloudSurfLast->points[j].x - pointSel.x) + 
                                 (laserCloudSurfLast->points[j].y - pointSel.y) * 
                                 (laserCloudSurfLast->points[j].y - pointSel.y) + 
                                 (laserCloudSurfLast->points[j].z - pointSel.z) * 
                                 (laserCloudSurfLast->points[j].z - pointSel.z);

                    if (int(laserCloudSurfLast->points[j].intensity) >= closestPointScan) {
                        if (pointSqDis < minPointSqDis2) {
                            minPointSqDis2 = pointSqDis;
                            minPointInd2 = j;
                        }
                    } else {
                        if (pointSqDis < minPointSqDis3) {
                            minPointSqDis3 = pointSqDis;
                            minPointInd3 = j;
                        }
                    }
                }
            }

            pointSearchSurfInd1[i] = closestPointInd;
            pointSearchSurfInd2[i] = minPointInd2;
            pointSearchSurfInd3[i] = minPointInd3;
        }

        if (pointSearchSurfInd2[i] >= 0 && pointSearchSurfInd3[i] >= 0) {

            tripod1 = laserCloudSurfLast->points[pointSearchSurfInd1[i]];
            tripod2 = laserCloudSurfLast->points[pointSearchSurfInd2[i]];
            tripod3 = laserCloudSurfLast->points[pointSearchSurfInd3[i]];

            float pa = (tripod2.y - tripod1.y) * (tripod3.z - tripod1.z) 
                     - (tripod3.y - tripod1.y) * (tripod2.z - tripod1.z);
            float pb = (tripod2.z - tripod1.z) * (tripod3.x - tripod1.x) 
                     - (tripod3.z - tripod1.z) * (tripod2.x - tripod1.x);
            float pc = (tripod2.x - tripod1.x) * (tripod3.y - tripod1.y) 
                     - (tripod3.x - tripod1.x) * (tripod2.y - tripod1.y);
            float pd = -(pa * tripod1.x + pb * tripod1.y + pc * tripod1.z);

            float ps = sqrt(pa * pa + pb * pb + pc * pc);

            pa /= ps;
            pb /= ps;
            pc /= ps;
            pd /= ps;

            float pd2 = pa * pointSel.x + pb * pointSel.y + pc * pointSel.z + pd;

            float s = 1;
            if (iterCount >= 5) {
                s = 1 - 1.8 * fabs(pd2) / sqrt(sqrt(pointSel.x * pointSel.x
                        + pointSel.y * pointSel.y + pointSel.z * pointSel.z));
            }

            if (s > 0.1 && pd2 != 0) {
                coeff.x = s * pa;
                coeff.y = s * pb;
                coeff.z = s * pc;
                coeff.intensity = s * pd2;

                laserCloudOri->push_back(surfPointsFlat->points[i]);
                coeffSel->push_back(coeff);
            }
        }
    }
}
```

---

LeGO-LOAM의 line-by-line 설명 시리즈입니다.
