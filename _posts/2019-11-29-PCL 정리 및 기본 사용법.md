# PCL cheat sheet

## PCL 선언하는 법 & T Type

pcl type 종류 참고

(주로 3D LiDAR를 사용할 때는 pcl::PointXYZ, pcl::PointXYZI, pcl::PointXYZNormal를 많이 사용)


http://www.pointclouds.org/documentation/tutorials/adding_custom_ptype.php#adding-custom-ptype

```cpp
pcl::PointCloud<pcl::PointXYZ> cloud;
pcl::PointCloud<pcl::PointXYZI> cloud;
pcl::PointCloud<pcl::PointNormal> cloud;
```
## 

기본적으로 pcl은 std::vector의 사용법과 유사하다.

<code>using namespace std;<code/>가 써져 있다고 

### 선언하는 법
```cpp
pcl::PointCloud<pcl::PointXYZ> cloud;
cloud.resize(3); //cloud의 size를 3으로 설정 

cloud.points[0].x = 1;
cloud.points[0].y = 2;
cloud.points[0].z = 3;

cloud.points[1].x = 4;
cloud.points[1].y = 5;
cloud.points[1].z = 6;

cloud.points[2].x = 7;
cloud.points[2].y = 8;
cloud.points[2].z = 9;

```

or
```cpp
pcl::PointCloud<pcl::PointXYZ> cloud;
pcl::PointXYZ point_xyz;

point_xyz.x = 1;
point_xyz.y = 2;
point_xyz.z = 3;
cloud.push_back(point_xyz);

point_xyz.x = 4;
point_xyz.y = 5;
point_xyz.z = 6;
cloud.push_back(point_xyz);

point_xyz.x = 7;
point_xyz.y = 8;
point_xyz.z = 9;
cloud.push_back(point_xyz);
```
출력을 하면 아래와 같은 결과를 볼 수 있다.
```cpp
for (int i = 0 ; i < cloud.size(); ++i){
      cout<<i<<": ";
      cout<<cloud.points[i].x<<", ";
      cout<<cloud.points[i].y<<", ";
      cout<<cloud.points[i].z<<endl;
      
  }
```
결과:
0: 1, 2, 3 
1: 4, 5, 6 
2: 7, 8, 9 

### Iterator

#### begin()

```cpp
cout<<cloud.begin()->x<<endl;
cout<<cloud.begin()->y<<endl;
cout<<cloud.begin()->z<<endl;
```
결과:
1<br/>
2<br/>
3<br/>

#### end()

```cpp
cout<<cloud.end()->x<<endl;
cout<<cloud.end()->y<<endl;
cout<<cloud.end()->z<<endl;
```
#### back()

``cpp
cout<<cloud.back().x<<endl;
cout<<cloud.back().y<<endl;
cout<<cloud.back().z<<endl;
```

```cpp
```

### 두 PointCloud 합치기

## PCL pointer 선언

```cpp
pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>());
pcl::PointCloud<pcl::PointXYZI>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZI>());
pcl::PointCloud<pcl::PointNormal>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZNormal>());
```



