---
layout: post
title: LeGO-LOAM 상세 설명 - 2. ImageProjection
subtitle: Introduction
tags: [SLAM, LiDAR, Pointcloud, ROS, PCL, LeGO-LOAM]
comments: true

---

# ImageProjection in LeGO-LOAM

`imageProjection.cpp`에서는 3D LiDAR sensor로 취득한 point cloud를 range image로 projection을 한 후에, preprocessing을 진행한다. 그로 인해, 3D point cloud 상의 각 포인트를 `segmentedCloud`와 `outlierCloud`로 binary classification을 진행한다. 이는 `featureAssociation.cpp`에서 향후 t-1와 t의 3D point cloud를 입력으로 relative pose를 구할 때 드는 연산량을 줄여준다. 

요약하자면, `imageProjection.cpp`의 역할은 아래와 같이 3가지로 꼽을 수 있다.

1. `featureAssociation.cpp`에서 interpolation 부분에서 쓸 `segMsg.orientationDiff` 세팅 (in `findStartEndAngle()` 함수)
2. 유효한 segment와 그렇지 않은 것들로 포인트를 구분함
    * 그렇지 않은 것들: ground points + 다소 noisy한 points들 (sub-cluster라고 부름. clustering을 했더니 너무 포인트 수가 적은 cloud points들)

## Overview

각 3D point cloud가 들어오면 아래와 같은 `cloudHandler` callback이 실행되고, 아래와 같이 7 step으로 구성되어 있다.

```c++
void cloudHandler(const sensor_msgs::PointCloud2ConstPtr& laserCloudMsg){
    // 1. Convert ros message to pcl point cloud
    copyPointCloud(laserCloudMsg);
    // 2. Start and end angle of a scan
    findStartEndAngle();
    // 3. Range image projection
    projectPointCloud();
    // 4. Mark ground points
    groundRemoval();
    // 5. Point cloud segmentation
    cloudSegmentation();
    // 6. Publish all clouds
    publishCloud();
    // 7. Reset parameters for next iteration
    resetParameters();
}
```

---

### 핵심 변수들

#### Decision making을 위한 내부 멤버 변수들
Step 4와 5에서 각 point의 상태를 판별하는 게 다소 헷갈리는데, 미리 정리를 하자면 아래와 같다.

크게 이 preprocessing 단계에서 가장 중요한 변수는 아래와 같은 세 개의 matrix이다.

```cpp
cv::Mat rangeMat; // range matrix for range image
cv::Mat labelMat; // label matrix for segmentaiton marking
cv::Mat groundMat; // ground matrix for ground cloud marking
```
각 matrix의 각 값은 아래와 같다 ~~matrix의  status를 #define을 통해서 정의해줬으면 이해하기 편했을텐데...~~

* `rangeMat`
    * `FLT_MAX`로 initialization
    * 한 point가 pixel에 해당하면 센서 프레임으로부터 그 point까지의 거리로 채워짐

* `groundMat`
    * 0으로 initialization. 그 후, non-ground의 label로 사용됨   
    * -1: 유효하지 않은 값, 접지점인지 여부를 판단할 수 없음을 의미
    * 1: Ground로 판명

* `labelMat`
    * 0으로 initialization    
    * -1: 해당하는 pixel의 `groundMat` 값이 1이거나, `rangeMat`의 값이 `FLT_MAX`일 때



추가적으로, 이러한 matrix들과 `fullCloud`, `fullInfoCloud`는 아래와 같이 initialization이 된다.

```cpp
// in `allocateMemory()`
fullCloud->points.resize(N_SCAN*Horizon_SCAN);
fullInfoCloud->points.resize(N_SCAN*Horizon_SCAN);

// in `resetParameters()`
rangeMat = cv::Mat(N_SCAN, Horizon_SCAN, CV_32F, cv::Scalar::all(FLT_MAX));
groundMat = cv::Mat(N_SCAN, Horizon_SCAN, CV_8S, cv::Scalar::all(0));
labelMat = cv::Mat(N_SCAN, Horizon_SCAN, CV_32S, cv::Scalar::all(0));

std::fill(fullCloud->points.begin(), fullCloud->points.end(), nanPoint);
std::fill(fullInfoCloud->points.begin(), fullInfoCloud->points.end(), nanPoint);
```

여기서 `nanPoint`는 아래와 같이 정의되어 있는데,
```cpp
nanPoint.x = std::numeric_limits<float>::quiet_NaN();
nanPoint.y = std::numeric_limits<float>::quiet_NaN();
nanPoint.z = std::numeric_limits<float>::quiet_NaN();
nanPoint.intensity = -1;
```

그래서 향후에 `fullCloud->points`의 각 point의 intensity가 -1인지 아닌지를 판별하여 현재 상태가 유효한지 아닌지를 판별한다 (step 4. groundRemoval() 참조)

#### 최종 output message

최종적으로, `featureAssociation.cpp`의 입력값으로 되는 `segMsg`는 아래와 같은 멤버 변수를 지니고 있다.
```cpp
segMsg.startRingIndex.assign(N_SCAN, 0);
segMsg.endRingIndex.assign(N_SCAN, 0);

segMsg.segmentedCloudGroundFlag.assign(N_SCAN*Horizon_SCAN, false);
segMsg.segmentedCloudColInd.assign(N_SCAN*Horizon_SCAN, 0);
segMsg.segmentedCloudRange.assign(N_SCAN*Horizon_SCAN, 0);
```

---

### 2. findStartEndAngle();

```cpp
void findStartEndAngle(){
    // start and end orientation of this cloud
    segMsg.startOrientation = -atan2(laserCloudIn->points[0].y, laserCloudIn->points[0].x);
    segMsg.endOrientation   = -atan2(laserCloudIn->points[laserCloudIn->points.size() - 1].y,
                                                 laserCloudIn->points[laserCloudIn->points.size() - 1].x) + 2 * M_PI;

    if (segMsg.endOrientation - segMsg.startOrientation > 3 * M_PI) {
        segMsg.endOrientation -= 2 * M_PI;
    } else if (segMsg.endOrientation - segMsg.startOrientation < M_PI)
        segMsg.endOrientation += 2 * M_PI;
    segMsg.orientationDiff = segMsg.endOrientation - segMsg.startOrientation;
}
```
(`segMsg.startOrientation`, `segMsg.endOrientation`)를 출력해보면 시간이 지남에 따라 
(-118.59, 259.08), (-100.85, 276.93), (-82.98, 294.76), (-65.16, 312.58) (-47.33, 330.62), (-29.3, 348.7), (-11.22, 366.56), (6.66, 384.53), (24.63, 402.56), (42.61, 420.44), (60.51, 438.03), (78.08, 455.49) ... 과 같이 약 18도 정도 정도 shift가 되면서 일어남.

`segMsg.orientationDiff` 전체 회전한 정도를 체크한다. 이는 아래와 같이 `featureAssociation.cpp`에서 각 포인트의 상대적인 시간, i.e. `relTime`을 지정할 때 사용된다.

```cpp
// adjustDistortion() in featureAssociation.cpp
float relTime = (ori - segInfo.startOrientation) / segInfo.orientationDiff;
point.intensity = int(segmentedCloud->points[i].intensity) + scanPeriod * relTime;
```

### 3. projectPointCloud()

```cpp
void projectPointCloud(){
    // range image projection
    float verticalAngle, horizonAngle, range;
    size_t rowIdn, columnIdn, index, cloudSize; 
    PointType thisPoint;

    cloudSize = laserCloudIn->points.size();

    for (size_t i = 0; i < cloudSize; ++i){

        thisPoint.x = laserCloudIn->points[i].x;
        thisPoint.y = laserCloudIn->points[i].y;
        thisPoint.z = laserCloudIn->points[i].z;
        // find the row and column index in the iamge for this point
        if (useCloudRing == true){
            rowIdn = laserCloudInRing->points[i].ring;
        }
        else{
            verticalAngle = atan2(thisPoint.z, sqrt(thisPoint.x * thisPoint.x + thisPoint.y * thisPoint.y)) * 180 / M_PI;
            rowIdn = (verticalAngle + ang_bottom) / ang_res_y;
        }
        if (rowIdn < 0 || rowIdn >= N_SCAN)
            continue;

        horizonAngle = atan2(thisPoint.x, thisPoint.y) * 180 / M_PI;

        columnIdn = -round((horizonAngle-90.0)/ang_res_x) + Horizon_SCAN/2;

        if (columnIdn >= Horizon_SCAN)
            columnIdn -= Horizon_SCAN;

        if (columnIdn < 0 || columnIdn >= Horizon_SCAN)
            continue;

        range = sqrt(thisPoint.x * thisPoint.x + thisPoint.y * thisPoint.y + thisPoint.z * thisPoint.z);
        if (range < sensorMinimumRange)
            continue;

        rangeMat.at<float>(rowIdn, columnIdn) = range;

        thisPoint.intensity = (float)rowIdn + (float)columnIdn / 10000.0;

        index = columnIdn  + rowIdn * Horizon_SCAN;
        fullCloud->points[index] = thisPoint;
        fullInfoCloud->points[index] = thisPoint;
        fullInfoCloud->points[index].intensity = range; // the corresponding range of a point is saved as "intensity"
    }
}
```

void projectPointCloud()라이더 데이터를 16x1800 포인트 클라우드 어레이로 생각하십시오. 그런 다음 각 포인트 클라우드에서 반환된 XYZ 데이터를 기반으로 각 포인트 클라우드를 이 배열에 매핑합니다.

수직각을 계산하려면 atan2함수를 사용하여 계산하십시오.
계산된 수직각을 통해 해당 라인의 일련번호를 구하고, 이때 라이다의 수평방향 라인번호를 계산한다 rowIdn. rowIdn아래에서 위로 세어 -15도를 초기 줄인 0번째 줄로 기록하여 총 16줄( N_SCAN=16)을 기록한다.
수평 방향의 각도를 찾습니다 horizonAngle = atan2(thisPoint.x, thisPoint.y) * 180 / M_PI;.
수평 방향의 각도에서 열 벡터를 계산합니다 columnIdn. 여기의 데이터 처리는 독창적이고 처음에는 이상하다고 생각했지만 나중에 실제로 그렇게 하면 데이터가 왜곡될 가능성이 적다는 것을 알게 되었습니다. 계산 columnIdn은 주로 다음 세 가지 진술입니다.

### 4. groundRemoval()

그라운드 포인트를 추출하기 전에 먼저 한 가지 점을 명확히 할 필요가 있습니다. 라이다를 설치할 때 수평입니다. 일반적으로 중간에 레이저 빔이 수평 평면에 평행하다고 믿어집니다. 따라서 16 라인의 경우 라이더에서 그라운드 포인트는 처음 7개의 레이저 빔에서 추출됩니다. 즉 groundScanInd=7, 처음 7개 번들의 모든 포인트 클라우드를 순회합니다.
```cpp
void groundRemoval(){
    size_t lowerInd, upperInd;
    float diffX, diffY, diffZ, angle;
    // groundMat
    // -1, no valid info to check if ground of not
    //  0, initial value, after validation, means not ground
    //  1, ground
    for (size_t j = 0; j < Horizon_SCAN; ++j){
        for (size_t i = 0; i < groundScanInd; ++i){

            lowerInd = j + ( i )*Horizon_SCAN;
            upperInd = j + (i+1)*Horizon_SCAN;

            if (fullCloud->points[lowerInd].intensity == -1 ||
                fullCloud->points[upperInd].intensity == -1){
                // no info to check, invalid points
                groundMat.at<int8_t>(i,j) = -1;
                continue;
            }

            diffX = fullCloud->points[upperInd].x - fullCloud->points[lowerInd].x;
            diffY = fullCloud->points[upperInd].y - fullCloud->points[lowerInd].y;
            diffZ = fullCloud->points[upperInd].z - fullCloud->points[lowerInd].z;

            angle = atan2(diffZ, sqrt(diffX*diffX + diffY*diffY) ) * 180 / M_PI;

            if (abs(angle - sensorMountAngle) <= 10){
                groundMat.at<int8_t>(i,j) = 1;
                groundMat.at<int8_t>(i+1,j) = 1;
            }
        }
    }
    // extract ground cloud (groundMat == 1)
    // mark entry that doesn't need to label (ground and invalid point) for segmentation
    // note that ground remove is from 0~N_SCAN-1, need rangeMat for mark label matrix for the 16th scan
    for (size_t i = 0; i < N_SCAN; ++i){
        for (size_t j = 0; j < Horizon_SCAN; ++j){
            if (groundMat.at<int8_t>(i,j) == 1 || rangeMat.at<float>(i,j) == FLT_MAX){
                labelMat.at<int>(i,j) = -1;
            }
        }
    }
    if (pubGroundCloud.getNumSubscribers() != 0){
        for (size_t i = 0; i <= groundScanInd; ++i){
            for (size_t j = 0; j < Horizon_SCAN; ++j){
                if (groundMat.at<int8_t>(i,j) == 1)
                    groundCloud->push_back(fullCloud->points[j + i*Horizon_SCAN]);
            }
        }
    }
}
```
### 5. cloudSegmentation()
```cpp
void cloudSegmentation(){
    // segmentation process
    for (size_t i = 0; i < N_SCAN; ++i)
        for (size_t j = 0; j < Horizon_SCAN; ++j)
            if (labelMat.at<int>(i,j) == 0)
                labelComponents(i, j);

    int sizeOfSegCloud = 0;
    // extract segmented cloud for lidar odometry
    for (size_t i = 0; i < N_SCAN; ++i) {

        segMsg.startRingIndex[i] = sizeOfSegCloud-1 + 5;
        // cout << i << ", "  << segMsg.startRingIndex[i] << ", " << segMsg.endRingIndex[i] << endl;

        for (size_t j = 0; j < Horizon_SCAN; ++j) {
            if (labelMat.at<int>(i,j) > 0 || groundMat.at<int8_t>(i,j) == 1){
                // outliers that will not be used for optimization (always continue)
                if (labelMat.at<int>(i,j) == 999999){
                    if (i > groundScanInd && j % 5 == 0){
                        outlierCloud->push_back(fullCloud->points[j + i*Horizon_SCAN]);
                        continue;
                    }else{
                        continue;
                    }
                }
                // majority of ground points are skipped
                if (groundMat.at<int8_t>(i,j) == 1){
                    if (j%5!=0 && j>5 && j<Horizon_SCAN-5)
                        continue;
                }
                // mark ground points so they will not be considered as edge features later
                segMsg.segmentedCloudGroundFlag[sizeOfSegCloud] = (groundMat.at<int8_t>(i,j) == 1);
                // mark the points' column index for marking occlusion later
                segMsg.segmentedCloudColInd[sizeOfSegCloud] = j;
                // save range info
                segMsg.segmentedCloudRange[sizeOfSegCloud]  = rangeMat.at<float>(i,j);
                // save seg cloud
                segmentedCloud->push_back(fullCloud->points[j + i*Horizon_SCAN]);
                // size of seg cloud
                ++sizeOfSegCloud;
            }
        }

        segMsg.endRingIndex[i] = sizeOfSegCloud-1 - 5;
        // cout << "==> " << i << ", "  << segMsg.startRingIndex[i] << ", " << segMsg.endRingIndex[i] << endl;
    }


    // extract segmented cloud for visualization
    if (pubSegmentedCloudPure.getNumSubscribers() != 0){
        for (size_t i = 0; i < N_SCAN; ++i){
            for (size_t j = 0; j < Horizon_SCAN; ++j){
                if (labelMat.at<int>(i,j) > 0 && labelMat.at<int>(i,j) != 999999){
                    segmentedCloudPure->push_back(fullCloud->points[j + i*Horizon_SCAN]);
                    segmentedCloudPure->points.back().intensity = labelMat.at<int>(i,j);
                }
            }
        }
    }
}
```


### 6. publishCloud() & 7. resetParameters()

그 후, `segMsg`와 visualization을 위해 ground, non-ground points가 publish되고 내부 변수들은 다음(t+1)의 point cloud preprocessing을 위해 reset됩니다. 자명하므로 생략.

 
---

LeGO-LOAM의 line-by-line 설명 시리즈입니다.
