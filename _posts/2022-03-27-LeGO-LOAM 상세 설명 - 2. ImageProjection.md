---
layout: post
title: LeGO-LOAM 상세 설명 - 2. ImageProjection
subtitle: Introduction
tags: [SLAM, LiDAR, Pointcloud, ROS, PCL, LeGO-LOAM]
comments: true

---

# ImageProjection in LeGO-LOAM

`imageProjection.cpp`에서는 3D LiDAR sensor로 취득한 point cloud를 range image로 projection을 한 후에, preprocessing을 진행한다. 그로 인해, 3D point cloud 상의 각 포인트를 `segmentedCloud`와 `outlierCloud`로 binary classification을 진행한다. 이는 `featureAssociation.cpp`에서 향후 t-1와 t의 3D point cloud를 입력으로 relative pose를 구할 때 드는 연산량을 줄여준다. 

요약하자면, `imageProjection.cpp`의 역할은 아래와 같이 3가지로 꼽을 수 있다.

1. `featureAssociation.cpp`에서 interpolation 부분에서 쓸 `segMsg.orientationDiff` 세팅 (in `findStartEndAngle()` 함수)
2. 전체 point cloud에서 ground points 추출
3. Non-ground points 중에서 다소 noisy한 points들 제거


## Overview

각 3D point cloud가 들어오면 아래와 같은 `cloudHandler` callback이 실행되고, 아래와 같이 7 step으로 구성되어 있다.

```c++
void cloudHandler(const sensor_msgs::PointCloud2ConstPtr& laserCloudMsg){
    // 1. Convert ros message to pcl point cloud
    copyPointCloud(laserCloudMsg);
    // 2. Start and end angle of a scan
    findStartEndAngle();
    // 3. Range image projection
    projectPointCloud();
    // 4. Mark ground points
    groundRemoval();
    // 5. Point cloud segmentation
    cloudSegmentation();
    // 6. Publish all clouds
    publishCloud();
    // 7. Reset parameters for next iteration
    resetParameters();
}
```

---

### 핵심 변수들

```
cv::Mat rangeMat; // range matrix for range image
cv::Mat labelMat; // label matrix for segmentaiton marking
cv::Mat groundMat; // ground matrix for ground cloud marking

// in `resetParameters()`
rangeMat = cv::Mat(N_SCAN, Horizon_SCAN, CV_32F, cv::Scalar::all(FLT_MAX));
groundMat = cv::Mat(N_SCAN, Horizon_SCAN, CV_8S, cv::Scalar::all(0));
labelMat = cv::Mat(N_SCAN, Horizon_SCAN, CV_32S, cv::Scalar::all(0));
```

각 matrix의 각 값은 아래와 같다 ~~matrix의  status를 #define을 통해서 정의해줬으면 이해하기 편했을텐데...~~

* `rangeMat`
    * `FLT_MAX`로 initialization
    * 한 point가 pixel에 해당하면 센서 프레임으로부터 그 point까지의 거리로 채워짐

* `groundMat`
    * 0으로 initialization   
    * -1: 유효하지 않은 값, 접지점인지 여부를 판단할 수 없음을 의미
    * 1: Ground로 판명

* `labelMat`
    * 0으로 initialization    
    * -1: 해당하는 pixel의 `groundMat` 값이 1이거나, `rangeMat`의 값이 `FLT_MAX`일 때

---
### 2. findStartEndAngle();

```cpp
void findStartEndAngle(){
    // start and end orientation of this cloud
    segMsg.startOrientation = -atan2(laserCloudIn->points[0].y, laserCloudIn->points[0].x);
    segMsg.endOrientation   = -atan2(laserCloudIn->points[laserCloudIn->points.size() - 1].y,
                                                 laserCloudIn->points[laserCloudIn->points.size() - 1].x) + 2 * M_PI;

    if (segMsg.endOrientation - segMsg.startOrientation > 3 * M_PI) {
        segMsg.endOrientation -= 2 * M_PI;
    } else if (segMsg.endOrientation - segMsg.startOrientation < M_PI)
        segMsg.endOrientation += 2 * M_PI;
    segMsg.orientationDiff = segMsg.endOrientation - segMsg.startOrientation;
}
```
(`segMsg.startOrientation`, `segMsg.endOrientation`)를 출력해보면 시간이 지남에 따라 
(-118.59, 259.08), (-100.85, 276.93), (-82.98, 294.76), (-65.16, 312.58) (-47.33, 330.62), (-29.3, 348.7), (-11.22, 366.56), (6.66, 384.53), (24.63, 402.56), (42.61, 420.44), (60.51, 438.03), (78.08, 455.49) ... 과 같이 약 18도 정도 정도 shift가 되면서 일어남.

`segMsg.orientationDiff` 전체 회전한 정도를 체크한다. 이는 아래와 같이 `featureAssociation.cpp`에서 각 포인트의 상대적인 시간, i.e. `relTime`을 지정할 때 사용된다.

```cpp
// adjustDistortion() in featureAssociation.cpp
float relTime = (ori - segInfo.startOrientation) / segInfo.orientationDiff;
point.intensity = int(segmentedCloud->points[i].intensity) + scanPeriod * relTime;
```

### 3. projectPointCloud()

void projectPointCloud()라이더 데이터를 16x1800 포인트 클라우드 어레이로 생각하십시오. 그런 다음 각 포인트 클라우드에서 반환된 XYZ 데이터를 기반으로 각 포인트 클라우드를 이 배열에 매핑합니다.

수직각을 계산하려면 atan2함수를 사용하여 계산하십시오.
계산된 수직각을 통해 해당 라인의 일련번호를 구하고, 이때 라이다의 수평방향 라인번호를 계산한다 rowIdn. rowIdn아래에서 위로 세어 -15도를 초기 줄인 0번째 줄로 기록하여 총 16줄( N_SCAN=16)을 기록한다.
수평 방향의 각도를 찾습니다 horizonAngle = atan2(thisPoint.x, thisPoint.y) * 180 / M_PI;.
수평 방향의 각도에서 열 벡터를 계산합니다 columnIdn. 여기의 데이터 처리는 독창적이고 처음에는 이상하다고 생각했지만 나중에 실제로 그렇게 하면 데이터가 왜곡될 가능성이 적다는 것을 알게 되었습니다. 계산 columnIdn은 주로 다음 세 가지 진술입니다.

### 4. groundRemoval()

### 5. cloudSegmentation()

### 6. publishCloud()

### 7. resetParameters()
 
---

LeGO-LOAM의 line-by-line 설명 시리즈입니다.
