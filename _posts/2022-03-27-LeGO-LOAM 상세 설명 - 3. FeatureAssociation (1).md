---
layout: post
title: LeGO-LOAM 상세 설명 - 3. FeatureAssociation (1)
subtitle: Feature Extraction
tags: [SLAM, LiDAR, Pointcloud, ROS, PCL, LeGO-LOAM]
comments: true
---

# FeatureAssociation in LeGO-LOAM (1) Feature Extraction

`featureAssociation.cpp`에서는 `imageProjection.cpp`에서 유효한 points들과 ground points를 추출한 후, 해당하는 값들로부터 (1) corner feature와 edge feature를 뽑고, (2) t-1과 t 사이의 relative odometry를 각 feature로부터 추정한다.

먼저 전체적으로 아래와 같이 200Hz로 (>10Hz) `runFeatureAssociation()` 함수를 계속 시행한다.

```cpp
int main(int argc, char** argv)
{
    ros::init(argc, argv, "lego_loam");

    ROS_INFO("\033[1;32m---->\033[0m Feature Association Started.");

    FeatureAssociation FA;

    ros::Rate rate(200);
    while (ros::ok())
    {
        ros::spinOnce();

        FA.runFeatureAssociation();

        rate.sleep();
    }
    
    ros::spin();
    return 0;
}
```

그리고 `runFeatureAssociation()` 함수는 아래와 같이 세 파트로 구성되어 있다.

```cpp
void runFeatureAssociation()
{
    /**
     0. Check whether the output of ImageProjection is coming or not
    */
    if (newSegmentedCloud && newSegmentedCloudInfo && newOutlierCloud &&
        std::abs(timeNewSegmentedCloudInfo - timeNewSegmentedCloud) < 0.05 &&
        std::abs(timeNewOutlierCloud - timeNewSegmentedCloud) < 0.05){

        newSegmentedCloud = false;
        newSegmentedCloudInfo = false;
        newOutlierCloud = false;
    }else{
        return;
    }
    /**
     1. Feature Extraction
    */
    adjustDistortion();

    calculateSmoothness();

    markOccludedPoints();

    extractFeatures();

    publishCloud(); // cloud for visualization

    /**
     2. Feature Association
    */
    if (!systemInitedLM) {
        checkSystemInitialization();
        return;
    }

    updateInitialGuess();

    updateTransformation();

    integrateTransformation();

    publishOdometry();

    publishCloudsLast(); // cloud to mapOptimization
}
```

가장 첫 번째로 FeatureAssociation으로 입력값들이 다 callback을 통해 할당되었는지 확인한다. 3D LiDAR sensor의 Hz가 10Hz임을 감안하면, 0.05 sec.의 timestamp 간격이 상당히 작다는 것을 알 수 있다. 하지만 ImageProjection단에서 거의 동시에 세 개의 message를 publish하기 때문에 서로간의 time delay가 적은게 정상이다.

```cpp
if (newSegmentedCloud && newSegmentedCloudInfo && newOutlierCloud &&
    std::abs(timeNewSegmentedCloudInfo - timeNewSegmentedCloud) < 0.05 &&
    std::abs(timeNewOutlierCloud - timeNewSegmentedCloud) < 0.05){

    newSegmentedCloud = false;
    newSegmentedCloudInfo = false;
    newOutlierCloud = false;
}else{
    return;
}
```

그 후, 데이터가 들어온 것을 확인하면 feature를 먼저 추출한 후 (feature extraction), t-1에서와 t에서의 feature 간의 correspondences를 찾아 relative pose를 추정한다. 

**NOTE**: LeGO-LOAM에서도 IMU data를 취급하지만, 실제로 돌려보면 IMU data를 사용했을 때 성능이 더 안 좋은 경우가 종종 발생한다. 이 것은 너무 naive하게 IMU 데이터를 축적했기 때문이다. 이러한 문제점들은 원저자의 후속연구인 [LIO-SAM](https://github.com/TixiaoShan/LIO-SAM)에서 GTSAM의 preintegration module을 도입해서 좀더 정밀한 initial guess pose를 IMU 데이터로부터 얻는다. 무튼, 본 글에서는 IMU callback은 들어오지 않는다고 가정한다. 

## Feature Extraction

### adjustDistortion()

먼저 `adjustDistortion()` 함수는 아래와 같다. (IMU data로 deskewing하는 부분은 생략한다. IMU data를 callback으로 안 받으면 `imuPointerLast`가 계속 -1으로 세팅되어 있어서 실행 안 됨. [원 코드](https://github.com/RobustFieldAutonomyLab/LeGO-LOAM/blob/master/LeGO-LOAM/src/featureAssociation.cpp) 참조)



```
void adjustDistortion()
{
    bool halfPassed = false;
    int cloudSize = segmentedCloud->points.size();

    PointType point;

    for (int i = 0; i < cloudSize; i++) {

        point.x = segmentedCloud->points[i].y;
        point.y = segmentedCloud->points[i].z;
        point.z = segmentedCloud->points[i].x;

        float ori = -atan2(point.x, point.z);
        if (!halfPassed) {
            if (ori < segInfo.startOrientation - M_PI / 2)
                ori += 2 * M_PI;
            else if (ori > segInfo.startOrientation + M_PI * 3 / 2)
                ori -= 2 * M_PI;

            if (ori - segInfo.startOrientation > M_PI)
                halfPassed = true;
        } else {
            ori += 2 * M_PI;

            if (ori < segInfo.endOrientation - M_PI * 3 / 2)
                ori += 2 * M_PI;
            else if (ori > segInfo.endOrientation + M_PI / 2)
                ori -= 2 * M_PI;
        }

        float relTime = (ori - segInfo.startOrientation) / segInfo.orientationDiff;
        point.intensity = int(segmentedCloud->points[i].intensity) + scanPeriod * relTime;

        segmentedCloud->points[i] = point;
    }
}
```

여기서 아래와 같이 point cloud의 좌표 축을 변환되는데 **별 이유 없다** ~~이 좌표축 변환은 후대의 많은 연구자들을 혼란에 빠뜨리고 마는데...~. 

![](/img/lego_loam_lidar_coordinate.png)

혹자는 이렇게 변환하는 이유가 manual 상의 Velodyne sensor의 좌표축때문이라고 그러는데, 그 것은 절대 아니다. 왜냐하면 Velodyne ROS driver를 통해 출력된 raw point cloud를 visualization하면 이미 아래와 같이 앞-왼쪽-윗쪽을 XYZ로 사용하고 있기 때문이다.

Point cloud at time t       |  Accumulated point cloud
:-------------------------:|:-------------------------:
![](/img/lego_loam_pc_at_t.png) |  ![](/img/lego_loam_pc_accum.png)

주변 SLAM 고수들에게 자문을 구한 결과, 이 행위는 LOAM 저자인 Ji Zhang씨가 LOAM 코드를 설계할 때 초기부터 camera와의 sensor fusion을 염두해두고 짠 것이어서 이렇게 좌표축 변환의 흔적이 남아있다고 한다 (진화적 퇴행 같이 LOAM 계열 LiDAR odometry 코드에는 이런 좌표축 변환이 남아있는 것이다). 그 증거를 코드 내부에서 확인할 수 있는데, 가장 대표적인 건 LiDAR odometry 코드임에도 불구하고 아래와 같이 visualization을 할 때 frame_id를 `/camera`로 사용하고 있다는 것이다.

```cpp
void publishCloud()
{
    sensor_msgs::PointCloud2 laserCloudOutMsg;

    if (pubCornerPointsSharp.getNumSubscribers() != 0){
        pcl::toROSMsg(*cornerPointsSharp, laserCloudOutMsg);
        laserCloudOutMsg.header.stamp = cloudHeader.stamp;
        laserCloudOutMsg.header.frame_id = "/camera";
        pubCornerPointsSharp.publish(laserCloudOutMsg);
    }

    if (pubCornerPointsLessSharp.getNumSubscribers() != 0){
        pcl::toROSMsg(*cornerPointsLessSharp, laserCloudOutMsg);
        laserCloudOutMsg.header.stamp = cloudHeader.stamp;
        laserCloudOutMsg.header.frame_id = "/camera";
        pubCornerPointsLessSharp.publish(laserCloudOutMsg);
    }

    if (pubSurfPointsFlat.getNumSubscribers() != 0){
        pcl::toROSMsg(*surfPointsFlat, laserCloudOutMsg);
        laserCloudOutMsg.header.stamp = cloudHeader.stamp;
        laserCloudOutMsg.header.frame_id = "/camera";
        pubSurfPointsFlat.publish(laserCloudOutMsg);
    }

    if (pubSurfPointsLessFlat.getNumSubscribers() != 0){
        pcl::toROSMsg(*surfPointsLessFlat, laserCloudOutMsg);
        laserCloudOutMsg.header.stamp = cloudHeader.stamp;
        laserCloudOutMsg.header.frame_id = "/camera";
        pubSurfPointsLessFlat.publish(laserCloudOutMsg);
    }
}
```

### calculateSmoothness()

그 후 아래와 같이 curvature 값을 구한다.

```cpp
void calculateSmoothness()
{
    int cloudSize = segmentedCloud->points.size();
    for (int i = 5; i < cloudSize - 5; i++) {

        float diffRange = segInfo.segmentedCloudRange[i-5] + segInfo.segmentedCloudRange[i-4]
                        + segInfo.segmentedCloudRange[i-3] + segInfo.segmentedCloudRange[i-2]
                        + segInfo.segmentedCloudRange[i-1] - segInfo.segmentedCloudRange[i] * 10
                        + segInfo.segmentedCloudRange[i+1] + segInfo.segmentedCloudRange[i+2]
                        + segInfo.segmentedCloudRange[i+3] + segInfo.segmentedCloudRange[i+4]
                        + segInfo.segmentedCloudRange[i+5];            

        cloudCurvature[i] = diffRange*diffRange;

        cloudNeighborPicked[i] = 0;
        cloudLabel[i] = 0;

        cloudSmoothness[i].value = cloudCurvature[i];
        cloudSmoothness[i].ind = i;
    }
}
```

Curvature 값은 아래와 같이 기하학적으로 해석할 수 있는데, 양 근처의 points들간의 거리의 합이 0에 가까운 경우에는 해당 포인트가 평평하다고 해석할 수 있고 (`cloudCurvature[i]`가 작음) 양 근처의 point들간의 거리의 합이 0이 안 되는 경우에는 얖 옆이 다른 경사로 이루어져 있거나 아래 그림과 같이 돌출되어 있다고 해석할 수 있다 (`cloudCurvature[i]`가 큼).

![](/img/lego_loam_curvatures_v2.png)

추가적으로, 이 글을 정리하다가 새롭게 안 사실인데, 현재 코드 상에서 i-k와 i+k는 (k=1, 2, 3, 4, 5)는 **인접한 픽셀 값이 아니다!**. ImageProjection의 `cloudSegmentation()` 함수에서 유효한 point들만 아래와 같이 차곡차곡 할당하는데, 

```cpp
// In `cloudSegmentation()` function in `imageProjection.cpp`
for (size_t j = 0; j < Horizon_SCAN; ++j) {
    if (labelMat.at<int>(i,j) > 0 || groundMat.at<int8_t>(i,j) == 1){
        // outliers that will not be used for optimization (always continue)
        if (labelMat.at<int>(i,j) == 999999){
            if (i > groundScanInd && j % 5 == 0){
                outlierCloud->push_back(fullCloud->points[j + i*Horizon_SCAN]);
                continue;
            }else{
                continue;
            }
        }
        // majority of ground points are skipped
        if (groundMat.at<int8_t>(i,j) == 1){
            if (j%5!=0 && j>5 && j<Horizon_SCAN-5)
                continue;
        }
        // mark ground points so they will not be considered as edge features later
        segMsg.segmentedCloudGroundFlag[sizeOfSegCloud] = (groundMat.at<int8_t>(i,j) == 1);
        // mark the points' column index for marking occlusion later
        segMsg.segmentedCloudColInd[sizeOfSegCloud] = j;
        // save range info
        segMsg.segmentedCloudRange[sizeOfSegCloud]  = rangeMat.at<float>(i,j);
        // save seg cloud
        segmentedCloud->push_back(fullCloud->points[j + i*Horizon_SCAN]);
        // size of seg cloud
        ++sizeOfSegCloud;
    }
}
```

그 결과, 아래의 그림과 같이 i-k와 i+k는 **가장 가까운 유효한 pixel**를 가리킨다는 것을 알 수 있다. 심지어 range image 끝 쪽에서는 위/아래쪽 채널이 비교가 된다. 향후 implementation을 해야할 일이 있으면 i-k과 i+k가 충분히 가까이 있어야 한다는 조건을 추가해야할 것 같다 (하지만 clustering으로 인해 대체로 valid segments들은 붙어있기 때문에, 위와 같이 해도 말이 되는 것 같다.





### markOccludedPoints()

```cpp
void markOccludedPoints()
{
    int cloudSize = segmentedCloud->points.size();

    for (int i = 5; i < cloudSize - 6; ++i){

        float depth1 = segInfo.segmentedCloudRange[i];
        float depth2 = segInfo.segmentedCloudRange[i+1];
        int columnDiff = std::abs(int(segInfo.segmentedCloudColInd[i+1] - segInfo.segmentedCloudColInd[i]));

        if (columnDiff < 10){

            if (depth1 - depth2 > 0.3){
                cloudNeighborPicked[i - 5] = 1;
                cloudNeighborPicked[i - 4] = 1;
                cloudNeighborPicked[i - 3] = 1;
                cloudNeighborPicked[i - 2] = 1;
                cloudNeighborPicked[i - 1] = 1;
                cloudNeighborPicked[i] = 1;
            }else if (depth2 - depth1 > 0.3){
                cloudNeighborPicked[i + 1] = 1;
                cloudNeighborPicked[i + 2] = 1;
                cloudNeighborPicked[i + 3] = 1;
                cloudNeighborPicked[i + 4] = 1;
                cloudNeighborPicked[i + 5] = 1;
                cloudNeighborPicked[i + 6] = 1;
            }
        }

        float diff1 = std::abs(float(segInfo.segmentedCloudRange[i-1] - segInfo.segmentedCloudRange[i]));
        float diff2 = std::abs(float(segInfo.segmentedCloudRange[i+1] - segInfo.segmentedCloudRange[i]));

        if (diff1 > 0.02 * segInfo.segmentedCloudRange[i] && diff2 > 0.02 * segInfo.segmentedCloudRange[i])
            cloudNeighborPicked[i] = 1;
    }
}
```


 
---

LeGO-LOAM의 line-by-line 설명 시리즈입니다.
