---
layout: post
title: LeGO-LOAM 상세 설명 - 3. FeatureAssociation (1)
subtitle: Feature Extraction
tags: [SLAM, LiDAR, Pointcloud, ROS, PCL, LeGO-LOAM]
comments: true
---

# FeatureAssociation in LeGO-LOAM (1) Feature Extraction

`featureAssociation.cpp`에서는 `imageProjection.cpp`에서 유효한 points들과 ground points를 추출한 후, 해당하는 값들로부터 (1) corner feature와 edge feature를 뽑고, (2) t-1과 t 사이의 relative odometry를 각 feature로부터 추정한다.

먼저 전체적으로 아래와 같이 200Hz로 (>10Hz) `runFeatureAssociation()` 함수를 계속 시행한다.

```cpp
int main(int argc, char** argv)
{
    ros::init(argc, argv, "lego_loam");

    ROS_INFO("\033[1;32m---->\033[0m Feature Association Started.");

    FeatureAssociation FA;

    ros::Rate rate(200);
    while (ros::ok())
    {
        ros::spinOnce();

        FA.runFeatureAssociation();

        rate.sleep();
    }
    
    ros::spin();
    return 0;
}
```

그리고 `runFeatureAssociation()` 함수는 아래와 같이 세 파트로 구성되어 있다.

```cpp
void runFeatureAssociation()
{
    /**
     0. Check whether the output of ImageProjection is coming or not
    */
    if (newSegmentedCloud && newSegmentedCloudInfo && newOutlierCloud &&
        std::abs(timeNewSegmentedCloudInfo - timeNewSegmentedCloud) < 0.05 &&
        std::abs(timeNewOutlierCloud - timeNewSegmentedCloud) < 0.05){

        newSegmentedCloud = false;
        newSegmentedCloudInfo = false;
        newOutlierCloud = false;
    }else{
        return;
    }
    /**
     1. Feature Extraction
    */
    adjustDistortion();

    calculateSmoothness();

    markOccludedPoints();

    extractFeatures();

    publishCloud(); // cloud for visualization

    /**
     2. Feature Association
    */
    if (!systemInitedLM) {
        checkSystemInitialization();
        return;
    }

    updateInitialGuess();

    updateTransformation();

    integrateTransformation();

    publishOdometry();

    publishCloudsLast(); // cloud to mapOptimization
}
```

가장 첫 번째로 FeatureAssociation으로 입력값들이 다 callback을 통해 할당되었는지 확인한다. 3D LiDAR sensor의 Hz가 10Hz임을 감안하면, 0.05 sec.의 timestamp 간격이 상당히 작다는 것을 알 수 있다. 하지만 ImageProjection단에서 거의 동시에 세 개의 message를 publish하기 때문에 서로간의 time delay가 적은게 정상이다.

```cpp
if (newSegmentedCloud && newSegmentedCloudInfo && newOutlierCloud &&
    std::abs(timeNewSegmentedCloudInfo - timeNewSegmentedCloud) < 0.05 &&
    std::abs(timeNewOutlierCloud - timeNewSegmentedCloud) < 0.05){

    newSegmentedCloud = false;
    newSegmentedCloudInfo = false;
    newOutlierCloud = false;
}else{
    return;
}
```

그 후, 데이터가 들어온 것을 확인하면 feature를 먼저 추출한 후 (feature extraction), t-1에서와 t에서의 feature 간의 correspondences를 찾아 relative pose를 추정한다. 

**NOTE**: LeGO-LOAM에서도 IMU data를 취급하지만, 실제로 돌려보면 IMU data를 사용했을 때 성능이 더 안 좋은 경우가 종종 발생한다. 이 것은 너무 naive하게 IMU 데이터를 축적했기 때문이다. 이러한 문제점들은 원저자의 후속연구인 [LIO-SAM](https://github.com/TixiaoShan/LIO-SAM)에서 GTSAM의 preintegration module을 도입해서 좀더 정밀한 initial guess pose를 IMU 데이터로부터 얻는다. 무튼, 본 글에서는 IMU callback은 들어오지 않는다고 가정한다. 

## Feature Extraction

### adjustDistortion()

먼저 `adjustDistortion()` 함수는 아래와 같다. (IMU data로 deskewing하는 부분은 생략한다. IMU data를 callback으로 안 받으면 `imuPointerLast`가 계속 -1으로 세팅되어 있어서 실행 안 됨. [원 코드](https://github.com/RobustFieldAutonomyLab/LeGO-LOAM/blob/master/LeGO-LOAM/src/featureAssociation.cpp) 참조)



```
void adjustDistortion()
{
    bool halfPassed = false;
    int cloudSize = segmentedCloud->points.size();

    PointType point;

    for (int i = 0; i < cloudSize; i++) {

        point.x = segmentedCloud->points[i].y;
        point.y = segmentedCloud->points[i].z;
        point.z = segmentedCloud->points[i].x;

        float ori = -atan2(point.x, point.z);
        if (!halfPassed) {
            if (ori < segInfo.startOrientation - M_PI / 2)
                ori += 2 * M_PI;
            else if (ori > segInfo.startOrientation + M_PI * 3 / 2)
                ori -= 2 * M_PI;

            if (ori - segInfo.startOrientation > M_PI)
                halfPassed = true;
        } else {
            ori += 2 * M_PI;

            if (ori < segInfo.endOrientation - M_PI * 3 / 2)
                ori += 2 * M_PI;
            else if (ori > segInfo.endOrientation + M_PI / 2)
                ori -= 2 * M_PI;
        }

        float relTime = (ori - segInfo.startOrientation) / segInfo.orientationDiff;
        point.intensity = int(segmentedCloud->points[i].intensity) + scanPeriod * relTime;

        segmentedCloud->points[i] = point;
    }

    imuPointerLastIteration = imuPointerLast;
}
```

여기서 아래와 같이 point cloud의 좌표 축을 변환되는데 **별 이유 없다** ~~이 코드는 후대의 많은 연구자들을 혼란에 빠뜨리고 마는데...~. 

![](/img/lego_loam_lidar_coordinate.png)

혹자는 이렇게 변환하는 이유가 manual 상의 Velodyne sensor의 좌표축때문이라고 그러는데, 그 것은 절대 아니다. 왜냐하면 Velodyne ROS driver를 통해 출력된 raw point cloud를 자체가 이미 앞-왼쪽-윗쪽을 XYZ로 사용하고 있기 때문이다.

Point cloud at time t       |  Accumulated point cloud
:-------------------------:|:-------------------------:
![](img/lego_loam_pc_at_t.png) |  ![](img/lego_loam_pc_accum.png)

### calculateSmoothness()

### markOccludedPoints()

### extractFeatures()



 
---

LeGO-LOAM의 line-by-line 설명 시리즈입니다.
