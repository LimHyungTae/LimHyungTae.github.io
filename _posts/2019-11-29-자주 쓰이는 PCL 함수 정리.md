# PCL cheat sheet


## Conversion

### sensor_msgs::PointCloud2 :arrow_right: pcl::PointCloud
```cpp
pcl::PointCloud<pcl::PointXYZ> cloudmsg2cloud(sensor_msgs::PointCloud2 cloudmsg)
  {
    pcl::PointCloud<pcl::PointXYZ> cloud_dst;
    pcl::fromROSMsg(cloudmsg,cloud_dst);
    return cloud_dst;
  }
```
### pcl::PointCloud :arrow_right: sensor_msgs::PointCloud2
```cpp
sensor_msgs::PointCloud2 cloud2cloudmsg(pcl::PointCloud<pcl::PointXYZ> cloud_src)
  {
    sensor_msgs::PointCloud2 cloudmsg;
    pcl::toROSMsg(cloudsrc,cloudmsg);
    return cloudmsg;
  }
```

### sensor_msgs::LaserScan :arrow_right: sensor_msgs::PointCloud2
```cpp

#include "laser_geometry/laser_geometry.h"

sensor_msgs::PointCloud2 laser2cloudmsg(sensor_msgs::LaserScan laser)
    {
      static laser_geometry::LaserProjection projector;
      sensor_msgs::PointCloud2 pc2_dst;
      projector.projectLaser(laser, pc2_dst,-1,laser_geometry::channel_option::Intensity | laser_geometry::channel_option::Distance);
      pc2_dst.header.frame_id = "map";

      return pc2_dst;
    }
```


## Transformation
```cpp
//Input: pcl::PointCloud source, cloud_src
//Output: Transformed pcl::PointCloud, pc_transformed via 4x4 transformation matrix

pcl::PointCloud<pcl::PointXYZ> pc_transformed;
pcl::PointCloud<pcl::PointXYZ>::Ptr ptr_transformed(new pcl::PointCloud<pcl::PointXYZ>);

Eigen::Matrix4f trans;
trans<< 1,   0,  0, 0.165,
        0,   1,  0, 0.000,
        0,   0,  1, 0.320,
        0,   0,  0,     1;
pcl::transformPointCloud(cloud_src, *ptr_transformed, trans);

pc_transformed = *ptr_transformed
```

## Filtering
```cpp
//Input: pcl::PointCloud source, cloud_src
//Output: Filtered pcl::PointCloud, pc_filtered along z axis, from 0.5m to 100.0m

pcl::PointCloud<pcl::PointXYZ> pc_filtered;
pcl::PointCloud<pcl::PointXYZ>::Ptr ptr_filtered(new pcl::PointCloud<pcl::PointXYZ>);
pcl::PassThrough<pcl::PointXYZ> filter;

float min_range = 0.5;
float max_range = 100.0;
*ptr_filtered = cloud_src;

filter.setInputCloud(ptr_filtered);
filter.setFilterFieldName("z");
filter.setFilterLimits(min_range, max_range);
filter.filter(*ptr_filtered);

pc_filtered = *ptr_filtered;
```


## Test
```cpp
pcl::fromROSMsg(pose_vec.back().pc2, cloud_t);
pcl::PointCloud<pcl::PointXYZ> cloud_t_cut_by_dist = cvt::cloud2cloudcut(cloud_t,pcl::PointXYZ(0,0,0),0.5,20);
Eigen::Matrix4f tf_velodyne2base = cvt::geoPose2eigen(pose_vec.back().T_laser2rt);
Eigen::Matrix4f tf_base2origin = cvt::geoPose2eigen(pose_vec.back().T_laser2rt);
pcl::transformPointCloud(cloud_t_cut_by_dist, cloud_t, tf_base2origin * tf_velodyne2base);
```

##
```cpp
Eigen::Matrix4f transform_base = Eigen::Matrix4f::Identity(4,4);
  /*Convert Pontcloud msgs to pcl::pointcloud*/
  pcl::PCLPointCloud2 pcl_pc2;
  pcl_conversions::toPCL(msg.query_pts,pcl_pc2);
  pcl::fromPCLPointCloud2(pcl_pc2,*pointcloud_query);
  pcl_conversions::toPCL(msg.train_pts,pcl_pc2);
  pcl::fromPCLPointCloud2(pcl_pc2,*pointcloud_train);
  /*Voxelize each query and train pointcloud into specific point size*/
  pcl::VoxelGrid<pcl::PointXYZ> voxelfilt;
  voxelfilt.setInputCloud(pointcloud_query);
  voxelfilt.setLeafSize(m_var_voxelsize,m_var_voxelsize,m_var_voxelsize);
  voxelfilt.filter(*pointcloud_query_voxel);
  voxelfilt.setInputCloud(pointcloud_train);
  voxelfilt.setLeafSize(m_var_voxelsize,m_var_voxelsize,m_var_voxelsize);
  voxelfilt.filter(*pointcloud_train_voxel);
```
## Hey
```cpp
   std::cout<<"Receiving " <<msg->idx<<"th synced data!"<<std::endl;
////For scan0 data
   pcl::PointCloud<pcl::PointXYZ> scan0_pc;
   pcl::fromROSMsg(msg->scan0, scan0_pc);
   std::cout<<"[MERGER]: scan0 - "<<scan0_pc.points.size()<<std::endl;
////For scan1 data
   pcl::PointCloud<pcl::PointXYZ> scan1_pc;
   pcl::PointCloud<pcl::PointXYZ>::Ptr filtered(new pcl::PointCloud<pcl::PointXYZ>);
   pcl::fromROSMsg(msg->scan1, scan1_pc);

   Eigen::Matrix4f trans;
   //// Case 1 trasformation
//   trans<<      1,        0,  0,   -0.1,
//                0,        1,  0,   1.76,
//                0,        0,  1,      0,
//                0,        0,  0,      1;

   //// Case 2 trasformation - In CARPE
   trans<<      0,        1,  0,   1.54,
               -1,        0,  0,   1.54,
                0,        0,  1,      0,
                0,        0,  0,      1;

   //// Case 3 trasformation - In Lab
//   trans<<     -1,        0,  0,   3.08,
//                0,       -1,  0,      0,
//                0,        0,  1,      0,
//                0,        0,  0,      1;

```cpp
   pcl::transformPointCloud(scan1_pc,*filtered,trans);
   // For debugging
   std::cout<<"[MERGER]: scan1 - "<<filtered->points.size()<<std::endl;
   pcl::PointCloud<pcl::PointXYZ> merged_pc;
   merged_pc = scan0_pc;
   merged_pc += *filtered;

   m_pub_bf_filtered_debug.publish(cvt::cloud2msg(merged_pc));

   //// Filtering using statistical outlier removal
   pcl::PointCloud<pcl::PointXYZ>::Ptr sor_filtered(new pcl::PointCloud<pcl::PointXYZ>);
   *sor_filtered = merged_pc;

   //// Filter wall pts
   pcl::PassThrough<pcl::PointXYZ> filter;
   filter.setInputCloud(sor_filtered);
   filter.setFilterFieldName("x");
   filter.setFilterLimits(-2.0, 3.3);
   filter.filter(*sor_filtered);

   filter.setInputCloud(sor_filtered);
   filter.setFilterFieldName("y");
   filter.setFilterLimits(-3, 100);
   filter.filter(*sor_filtered);


   pcl::StatisticalOutlierRemoval<pcl::PointXYZ> sor;
   sor.setInputCloud (sor_filtered);
   // Set neighbors to analyze for each point
   sor.setMeanK (10);
   sor.setStddevMulThresh (1.0);
   sor.filter(*sor_filtered);

   m_pub_after_filtered_debug.publish(cvt::cloud2msg(*sor_filtered));

   //// Segment points
   pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_f(new pcl::PointCloud<pcl::PointXYZ>);
   pcl::SACSegmentation<pcl::PointXYZ> seg;
   pcl::PointIndices::Ptr inliers (new pcl::PointIndices);
   pcl::ModelCoefficients::Ptr coefficients (new pcl::ModelCoefficients);
   pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_plane (new pcl::PointCloud<pcl::PointXYZ> ());
   seg.setOptimizeCoefficients (true);
   seg.setModelType (pcl::SACMODEL_PLANE);
   seg.setMethodType (pcl::SAC_RANSAC);
   seg.setMaxIterations (100);
   seg.setDistanceThreshold (0.02);

   // Creating the KdTree object for the search method of the extraction
   pcl::search::KdTree<pcl::PointXYZ>::Ptr tree (new pcl::search::KdTree<pcl::PointXYZ>);
   tree->setInputCloud (sor_filtered);

   std::vector<pcl::PointIndices> cluster_indices;
   pcl::EuclideanClusterExtraction<pcl::PointXYZ> ec;

   //  If too small, it can happen that an actual object can be seen as multiple clusters
   //  multiple objects are seen as one cluster.
   ec.setClusterTolerance (0.28); // 2cm
   ec.setMinClusterSize (5);
   ec.setMaxClusterSize (100);
   ec.setSearchMethod (tree);
   ec.setInputCloud (sor_filtered);

   ec.extract (cluster_indices);
```
